<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Deferred value — deferred • async</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Deferred value — deferred"><meta name="description" content="Deferred value"><meta property="og:description" content="Deferred value"></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">async</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.0.9004</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="../articles/internals.html">Internals of the async package</a></li>
    <li><a class="dropdown-item" href="../articles/async-example.html">Examples for the async package</a></li>
  </ul></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><a class="external-link nav-link" href="https://github.com/gaborcsardi/async" target="_blank"><span class="fa fa-github fa-lg"></span></a></li>
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://exmaple-domain.com" target="_blank">exmaple-domain.com</a></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Deferred value</h1>
      <small class="dont-index">Source: <a href="https://github.com/gaborcsardi/async/blob/main/R/deferred.R" class="external-link"><code>R/deferred.R</code></a></small>
      <div class="d-none name"><code>deferred.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>Deferred value</p>
    </div>


    <div class="section level2">
    <h2 id="usage">Usage<a class="anchor" aria-label="anchor" href="#usage"></a></h2>



<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>dx <span class="ot">&lt;-</span> deferred<span class="sc">$</span><span class="fu">new</span>(<span class="at">action =</span> <span class="cn">NULL</span>, <span class="at">on_progress =</span> <span class="cn">NULL</span>, <span class="at">on_cancel =</span> <span class="cn">NULL</span>,</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>         <span class="at">parents =</span> <span class="cn">NULL</span>, <span class="at">parent_resolve =</span> <span class="cn">NULL</span>, <span class="at">parent_reject =</span> <span class="cn">NULL</span>,</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>         <span class="at">type =</span> <span class="cn">NULL</span>)</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>dx<span class="sc">$</span><span class="fu">then</span>(on_fulfilled)</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>dx<span class="sc">$</span><span class="fu">catch</span>(...)</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>dx<span class="sc">$</span><span class="fu">finally</span>(on_finally)</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>dx<span class="sc">$</span><span class="fu">cancel</span>(<span class="at">reason =</span> <span class="st">"Cancelled"</span>)</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>dx<span class="sc">$</span><span class="fu">share</span>()</span></code></pre><p></p></div>
    </div>
    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<ul><li><p><code>action</code>: Function to call when the deferred value starts running.
it needs to have at least two arguments: <code>resolve</code> and <code>reject</code>,
and the third <code>progress</code> argument is optional. See details below.</p></li>
<li><p><code>on_progress</code>: A function to call to report progress. See details
below.</p></li>
<li><p><code>on_cancel</code>: A function to call when the deferred is cancelled. See
details below.</p></li>
<li><p><code>parents</code>: A list of deferred values that will be the parents of the
deferred value being created. If some of them are already owned,
an error is thrown.</p></li>
<li><p><code>parent_resolve</code>: A function to call when a parent is resolved.
See details below.</p></li>
<li><p><code>parent_reject</code>: A function to call when a parent throws an error.
See details below.</p></li>
<li><p><code>type</code>: A label that can be used to indicate the type of the deferred
value to create. This might be useful for debugging, but otherwise
it is not used.</p></li>
<li><p><code>on_fulfilled</code>: Function to call when the parent deferred is resolved.
Essentially this is the <code>parent_resolve</code> function of the <code>then()</code>
deferred.</p></li>
<li><p><code>...</code> Error handlers, as in <code><a href="https://rdrr.io/r/base/conditions.html" class="external-link">tryCatch()</a></code>, see details below.</p></li>
<li><p><code>on_finally</code>: Function to call, after the deferred value is resolved
or after it has thrown an error. It will be called without arguments.</p></li>
<li><p><code>reason</code> Error message or error object that will be used to cancel the
deferred.</p></li>
</ul></div>
    <div class="section level2">
    <h2 id="deferred-values">Deferred values<a class="anchor" aria-label="anchor" href="#deferred-values"></a></h2>



<p>Asynchronous computation is represented by deferred values.
A deferred value is an <a href="https://github.com/wch/R6" class="external-link">R6</a> object.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>deferred<span class="sc">$</span><span class="fu">new</span>(<span class="at">action =</span> <span class="cn">NULL</span>, <span class="at">on_progress =</span> <span class="cn">NULL</span>, <span class="at">on_cancel =</span> <span class="cn">NULL</span>,</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>   <span class="at">parents =</span> <span class="cn">NULL</span>, <span class="at">parent_resolve =</span> <span class="cn">NULL</span>, <span class="at">parent_reject =</span> <span class="cn">NULL</span>,</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>   <span class="at">type =</span> <span class="cn">NULL</span>)</span></code></pre><p></p></div>
<p>Creates a new deferred value. <code>action</code> is a function that is called
once the deferred value is <em>started</em> (i.e. <em>not</em> when <code>dx</code> is created).
It must have one or two arguments: <code>resolve</code>, or <code>resolve</code> and <code>progress</code>
It should call <code>resolve</code> when it is done, with the final value of the
deferred as the argument. (See examples below.) If it has two arguments,
then the second one is a callback function for creating progress bars.
The deferred value may report its progress through this function.
See details in the <em>Progress bars</em> section below.</p>
<p><code>action</code> is called when the evaluation of the deferred value is started.
Only deferred values that are needed to calculate the value of the
async phase, are evaluated. (See also <em>Lazy Evaluation</em> below.)</p>
<p>Note that <code>action</code> is optional, for some deferred values, no action is
takes when they are started. (These typically depend on their parent
nodes.)</p>
<p><code>on_cancel</code> is a function that is called without arguments when a
deferred value is cancelled. This includes explicit cancellation by
calling its <code>$cancel()</code> method, or auto-cancellation (see below).</p>
<p><code>parents</code> is a list of deferred values that need to be computed before
the current deferred value. When a parent deferred is resolved, the
<code>parent_resolve</code> function is called. When a parent referred throws an
error, the parent_reject` function is called.</p>
<p><code>parent_resolve</code> is a function with (up to) two arguments:
<code>value</code> and <code>resolve</code>. It will be called with the value of the
parent, the <code>resolve</code> callback of the deferred.
<code>parent_resolve</code> can resolve the deferred by calling the supplied <code>resolve</code>
callback, or it can keep waiting on other parents and/or external
computation. It may throw an error to fail the deferred.</p>
<p><code>parent_resolve</code> allows some shorthands as well:</p><ul><li><p><code>NULL</code>: the deferred is resolved with the value of the parent.</p></li>
<li><p>A function with no arguments: this function is called, and the deferred
resolves to its return value.</p></li>
<li><p>A function with one argument: this function is called with the value
of the parent as the argument, and the deferred is resolved to its
return value.</p></li>
<li><p>A function with arguments <code>value</code> and <code>resolve</code>. This function is
called with the value of the parent, and the resolve callback of the
deferred.</p></li>
</ul><p><code>parent_reject</code> is a function with (up to) two arguments:
<code>value</code>, <code>resolve</code>. It will be called with the error object
thrown by the parent.</p>
<p><code>parent_resolve</code> can resolve the deferred by calling the supplied
<code>resolve</code> callback, or it can keep waiting on other parents and/or
external computation. It may throw an error to fail the deferred. It may
also re-throw the error received from the parent, if it does not wish
to handle it.</p>
<p><code>parent_reject</code> also accepts some shorthands as well:</p><ul><li><p><code>NULL</code>: the deferred throws the same error as the parent.</p></li>
<li><p>A function with no arguments: this function is called, and the deferred
resolves to its return value.</p></li>
<li><p>A function with one argument: this function is called with the value
of the parent as the argument, and the deferred is resolved to its
return value.</p></li>
<li><p>A function with arguments <code>value</code> and <code>resolve</code>. This function is
called with the value of the parent, and the resolve callback of the
deferred.</p></li>
<li><p>A list of named error handlers, corresponding to the error handlers
of <code>$catch()</code> (and <code><a href="https://rdrr.io/r/base/conditions.html" class="external-link">tryCatch()</a></code>). If these error handlers handle the
parent's error, the deferred is resolved with the result of the
handlers. Otherwise the deferred will be failed with the parent's
error. The error handlers may also throw a new error.</p></li>
</ul></div>
    <div class="section level2">
    <h2 id="error-handling">Error handling<a class="anchor" aria-label="anchor" href="#error-handling"></a></h2>



<p>The action function of the deferred, and also the <code>parent_resolve</code> and
<code>parent_reject</code> handlers may throw errors if the deferred cannot be
computed. Errors can be handled wit the <code>$catch()</code> member function:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>dx<span class="sc">$</span><span class="fu">catch</span>(...)</span></code></pre><p></p></div>
<p>It takes the same named error handler arguments as <code><a href="https://rdrr.io/r/base/conditions.html" class="external-link">tryCatch()</a></code>.</p>
<p>Technically, <code>$catch()</code> creates a new deferred value, and this new
deferred value is resolved to the result of the error handlers. Of the
handlers do not handle the error, then the new deferred will fail
with the same error.</p>
<p>The <code>$finally()</code> method can be used to run create finalizer code that
runs when a deferred is resolved or when it fails. It can be used to
close database connections or other resources:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>dx<span class="sc">$</span><span class="fu">finally</span>(on_finally)</span></code></pre><p></p></div>
<p>Technically, <code>$finally()</code> creates a new deferred, which will resolve
or fail the same way as the original one, but before doing that it will
call the <code>on_finally</code> function with no arguments.</p>
    </div>
    <div class="section level2">
    <h2 id="builtin-async-functions">Builtin async functions<a class="anchor" aria-label="anchor" href="#builtin-async-functions"></a></h2>



<p>The async package comes with some basic async functions:</p><ul><li><p><code><a href="delay.html">delay()</a></code> sets a timer and then resolves to <code>TRUE</code>.</p></li>
<li><p><code><a href="async_constant.html">async_constant()</a></code> resolves successfully to its argument.</p></li>
<li><p><code><a href="http_get.html">http_get()</a></code> and <code><a href="http_head.html">http_head()</a></code> make HTTP GET and HEAD requests.</p></li>
</ul></div>
    <div class="section level2">
    <h2 id="combining-async-values">Combining async values<a class="anchor" aria-label="anchor" href="#combining-async-values"></a></h2>



<p>Async computation (just like ordinary sync computation) usually
consists of several steps that needs to be performed in the specified
order. The <code>$then()</code> method specifies that a step of computation needs
to be performed after the deferred value is known:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>dx<span class="sc">$</span><span class="fu">then</span>(on_fulfilled)</span></code></pre><p></p></div>
<p><code>on_fulfilled</code> is a function with zero or one formal arguments.
It will be called once the result of the deferred is known, with its
result. (The result is omitted if it has no arguments).</p>
<p><code>$then()</code> creates another deferred value, that will resolve to the
result of the <code>on_fulfilled</code> callback. Should this callback return
with a deferred value, then <code>$then()</code> the deferred value will be a
child of this newly creted deferred, and only resolve after that.</p>
<p>See also <code><a href="when_all.html">when_all()</a></code>, <code><a href="when_some.html">when_some()</a></code> and <code><a href="when_some.html">when_any()</a></code>, which can combine
multiple deferred values into one.</p>
<p>You cannot call <code>$then()</code> (or <code><a href="when_some.html">when_any()</a></code>, <code><a href="when_all.html">when_all()</a></code>, etc. on the
same deferred value multiple times, unless it is a shared deferred
value. See <em>Ownership</em> below.</p>
<p>The <code><a href="async_reflect.html">async_reflect()</a></code>, <code><a href="async_retry.html">async_retry()</a></code>, <code><a href="async_sequence.html">async_sequence()</a></code>,
<code><a href="async_timeout.html">async_timeout()</a></code>, <code><a href="async_until.html">async_until()</a></code> and <code><a href="async_whilst.html">async_whilst()</a></code> functions are
helpers for more complex async control flow.</p>
    </div>
    <div class="section level2">
    <h2 id="ownership">Ownership<a class="anchor" aria-label="anchor" href="#ownership"></a></h2>



<p>async follows a strong ownership model. Each deferred value must be
owned by exactly one other deferred value  (unless they are shared, see
below).</p>
<p>After a <code>dx2 &lt;- dx$then()</code> call, the <code>dx</code> deferred is <em>owned</em> by the
newly created deferred value. (The same applied to <code><a href="when_some.html">when_any()</a></code>, etc.)
This means that it is not possible to call <code>$then()</code> on the same
deferred value multiple times. The deferred value that is synchronized
by calling <code><a href="synchronise.html">synchronise()</a></code> on it, is owned by <code><a href="synchronise.html">synchronise()</a></code>, see
<em>Synchronization</em> below.</p>
<p>The deferred values of an async phase form a directed graph, which we
call the async DAG (directed, acyclic graph). Usually (when no deferred
is shared, see below), this DAG is a rooted tree, the root of the tree
is the synchronised deferred, the final result of the async phase.</p>
    </div>
    <div class="section level2">
    <h2 id="shared-deferred-values">Shared Deferred Values<a class="anchor" aria-label="anchor" href="#shared-deferred-values"></a></h2>



<p>In the rare cases when the strong ownership model is too restrictive,
a deferred value can be marked as <em>shared</em>:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>dx<span class="sc">$</span><span class="fu">share</span>()</span></code></pre><p></p></div>
<p>This has the following implications:</p><ul><li><p>A shared deferred value can have multiple children (owners) in the
async DAG.</p></li>
<li><p>A shared deferred value is started after its first child is started.</p></li>
<li><p>A shared deferred value is not auto-cancelled when all of its children
are finished. (Because it might have more children in the future.)</p></li>
<li><p>A shared deferred value is still auto-cancelled at the end of the
event loop.</p></li>
</ul><p>Use shared deferred values sparingly, only when they are really needed,
as they forbid auto-cancellation, so deferred values will hold on to
resources longer, until the async phase is finished.</p>
    </div>
    <div class="section level2">
    <h2 id="synchronization">Synchronization<a class="anchor" aria-label="anchor" href="#synchronization"></a></h2>



<p>async allows embedding asynchronous computation in synchronous code.
The execution of such a program has a sync phase and async phases. When the
program starts, it is in the sync phase. In the sync phase you cannot
create deferred values. (But you can still define (async) functions, that
will create deferred values when called.)</p>
<p>To enter into an async phase, call <code><a href="synchronise.html">synchronise()</a></code> on an expression that
evaluates to a deferred value. The async phase will last until this
deferred value is computed or an error is thrown (and the error reaches
<code><a href="synchronise.html">synchronise()</a></code>).</p>
<p><code><a href="synchronise.html">synchronise()</a></code> creates an event loop, which manages the computation of
the deferred values in this particular async phase.</p>
<p>Async phases can be embedded into each other. I.e. a program may call
<code><a href="synchronise.html">synchronise()</a></code> while in the async phase. The outer async phase's event
loop then stops until the inner async phase terminates. Deferred values
cannot be passed through a <code><a href="synchronise.html">synchronise()</a></code> barrier, to anoter (sync or
async phase). Should this happen, an error is reported on the first
operation on the leaked deferred value.</p>
<p>In a typical application, a function is implemented asynchronously, and
then used synchronously by the interactive user, or another piece of
synchronous code, via <code><a href="synchronise.html">synchronise()</a></code> calls. The following example makes
three HTTP requests in parallel:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>http_status3 <span class="ot">&lt;-</span> <span class="cf">function</span>() {</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>  http_status <span class="ot">&lt;-</span> <span class="cf">function</span>(url) {</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>    <span class="fu">http_get</span>(url)<span class="sc">$</span><span class="fu">then</span>(<span class="cf">function</span>(response) response<span class="sc">$</span>status_code)</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>  }</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>  r1 <span class="ot">&lt;-</span> <span class="fu">http_status</span>(<span class="st">"https://eu.httpbin.org/status/403"</span>)</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>  r2 <span class="ot">&lt;-</span> <span class="fu">http_status</span>(<span class="st">"https://eu.httpbin.org/status/404"</span>)</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>  r3 <span class="ot">&lt;-</span> <span class="fu">http_status</span>(<span class="st">"https://eu.httpbin.org/status/200"</span>)</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>  <span class="fu">when_all</span>(r1, r2, r3)</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>}</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="fu">synchronise</span>(<span class="fu">http_status3</span>())</span></code></pre><p></p></div>
<p>This async function can also be used asychronously, as a parent of
another deferred value, in an async phase.</p>
    </div>
    <div class="section level2">
    <h2 id="lazy-evaluation">Lazy evaluation<a class="anchor" aria-label="anchor" href="#lazy-evaluation"></a></h2>



<p>async does not evaluate deferred values that are not part of the async
DAG of the async phase. These are clearly not needed to compute the
result of the async phase, so it would be a waste of resources working on
them. (It is also unclear how their errors should be handled.)</p>
<p>In the following example, <code>d1</code> and <code>d2</code> are created, but they are not
part of the async DAG, so they are never evaluated.</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>do <span class="ot">&lt;-</span> <span class="cf">function</span>() {</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>  d1 <span class="ot">&lt;-</span> <span class="fu">delay</span>(<span class="dv">1</span><span class="sc">/</span><span class="dv">100</span>)<span class="sc">$</span><span class="fu">then</span>(<span class="cf">function</span>() <span class="fu">print</span>(<span class="st">"d1"</span>))</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>  d2 <span class="ot">&lt;-</span> d1<span class="sc">$</span><span class="fu">then</span>(<span class="cf">function</span>() <span class="fu">print</span>(<span class="st">"d2"</span>))</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>  d3 <span class="ot">&lt;-</span> <span class="fu">delay</span>(<span class="dv">1</span><span class="sc">/</span><span class="dv">100</span>)<span class="sc">$</span><span class="fu">then</span>(<span class="cf">function</span>() <span class="fu">print</span>(<span class="st">"d3"</span>))</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>  d4 <span class="ot">&lt;-</span> d3<span class="sc">$</span><span class="fu">then</span>(<span class="cf">function</span>() <span class="fu">print</span>(<span class="st">"d4"</span>))</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>  d4</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>}</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="fu">invisible</span>(<span class="fu">synchronise</span>(<span class="fu">do</span>()))</span></code></pre><p></p></div>
    </div>
    <div class="section level2">
    <h2 id="cancellation">Cancellation<a class="anchor" aria-label="anchor" href="#cancellation"></a></h2>



<p>The computation of a deferred can be cancelled when it is not needed
any more:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>dx<span class="sc">$</span><span class="fu">cancel</span>(<span class="at">reason =</span> <span class="st">"Cancelled"</span>)</span></code></pre><p></p></div>
<p>This will <em>fail</em> the children of the deferred, unless they have been
completed already. It will also auto-cancel the parent DAG of the
deferred, unless they are shared deferreds, see the next Section.</p>
    </div>
    <div class="section level2">
    <h2 id="auto-cancellation">Auto-cancellation<a class="anchor" aria-label="anchor" href="#auto-cancellation"></a></h2>



<p>In an async phase, it might happen that parts of the async DAG are not
needed for the final result any more. E.g. if a parent of a <code><a href="when_all.html">when_all()</a></code>
node throws an error, then the other parents don't have to be computed.
In this case the event loop of the phase automatically cancels these
deferred values. Similarly, if a single parent of a <code><a href="when_some.html">when_any()</a></code> node is
resolved, the other parents can be cancelled.</p>
<p>In general, if a node of the async DAG is resolved, the whole directed
DAG, rooted at that node, can be cancelled (except for nodes that were
already resolved and nodes that have already failed).</p>
<p>Auto-cancellation is very convenient, as you can be sure that resources
are free as soon as they are not needed. Some practical examples:</p><ul><li><p>Making HTTP requests to many mirror web sites, to check their response
time. As soon as the first reply is in, the rest of the HTTP requests
are cancelled.</p></li>
<li><p>In multi-process computation, as soon as one process fails, the rest are
automatically cancelled. (Unless the failure is handled, of course.)</p></li>
</ul><p>async also has another type of cancellation, when <code><a href="synchronise.html">synchronise()</a></code> is
interrupted externally, either by the user or some system error. In this
case all processes and resources that were created in the event loop,
are cancelled and freed.</p>
<p>Shared deferred values (see <code>$share()</code>) are not auto-cancelled when their
children are resolved or errored, but they are always cancelled at the
end of the async phase.</p>
    </div>
    <div class="section level2">
    <h2 id="progress-bars">Progress bars<a class="anchor" aria-label="anchor" href="#progress-bars"></a></h2>



<p>A deferred value may report on its progress, if its action has a progress
callback. The progress callback is called with a list that describes
and event. We suggest that it always has an <code>event</code> entry, which is a
simple string. The rest of the list entries can be defined as needed,
but typically there will be a counter counting ticks, or a ratio
describing what part of the computation is already. See <code><a href="http_get.html">http_get()</a></code>
for an async function that reports progress.</p>
    </div>
    <div class="section level2">
    <h2 id="collections-helper-functions">Collections helper functions<a class="anchor" aria-label="anchor" href="#collections-helper-functions"></a></h2>



<p>async provides some utilities that make it easier to deal with
collections of deferred values:</p>
<p>The current iterators:</p><ul><li><p><code><a href="async_map.html">async_map()</a></code> applies an async function to all elements of a vector or
list (collection).</p></li>
<li><p><code><a href="async_detect.html">async_detect()</a></code> finds an element of a collection that passed an async
truth test.</p></li>
<li><p><code><a href="async_every.html">async_every()</a></code> checks if every element of a collection satisfies an
async predicate. <code><a href="async_every.html">async_some()</a></code> checks if any element does that.</p></li>
<li><p><code><a href="async_filter.html">async_filter()</a></code> keeps elements that pass an async truth test.</p></li>
</ul></div>
    <div class="section level2">
    <h2 id="control-flow-helper-functions">Control flow helper functions<a class="anchor" aria-label="anchor" href="#control-flow-helper-functions"></a></h2>



<p>Control flow with deferred values can be challenging. Some helpers:</p><ul><li><p><code><a href="async_reflect.html">async_reflect()</a></code> creates an async function that always succeeds.
This is useful if you want to apply it to a collection, and don't
want to stop at the first error.</p></li>
<li><p><code><a href="async_retry.html">async_retry()</a></code> tries an async function a number of times.
<code><a href="async_retryable.html">async_retryable()</a></code> turns a regular function into a retryable one.</p></li>
<li><p><code><a href="async_sequence.html">async_sequence()</a></code> chains two async functions. Calling their sequence
is equivalent calling '$then()` on them, but <code><a href="async_sequence.html">async_sequence()</a></code> is
easier to use programmatically.</p></li>
<li><p><code><a href="async_until.html">async_until()</a></code> and <code><a href="async_whilst.html">async_whilst()</a></code> let you call an async function
repeatedly, until or while a (syncronous) condition holds.</p></li>
<li><p><code><a href="async_timeout.html">async_timeout()</a></code> runs an async function with a timeout.</p></li>
</ul></div>
    <div class="section level2">
    <h2 id="examples">Examples<a class="anchor" aria-label="anchor" href="#examples"></a></h2>


<p>Please see the README and the vignettes for examples.</p>
    </div>

  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by <a href="https://github.com/gaborcsardi" class="external-link">Gábor Csárdi</a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.</p>
</div>

    </footer></div>





  </body></html>

