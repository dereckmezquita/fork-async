<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Internals of the async package • async</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Internals of the async package">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">async</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.0.9004</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/internals.html">Internals of the async package</a></li>
    <li><a class="dropdown-item" href="../articles/async-example.html">Examples for the async package</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/gaborcsardi/async" target="_blank"><span class="fa fa-github fa-lg"></span></a></li>
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://exmaple-domain.com" target="_blank">exmaple-domain.com</a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Internals of the async package</h1>
                        <h4 data-toc-skip class="author">Gábor
Csárdi</h4>
            
            <h4 data-toc-skip class="date">2024-08-10</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/gaborcsardi/async/blob/main/vignettes/internals.Rmd" class="external-link"><code>vignettes/internals.Rmd</code></a></small>
      <div class="d-none name"><code>internals.Rmd</code></div>
    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/gaborcsardi/async#readme" class="external-link">async</a></span><span class="op">)</span></span></code></pre></div>
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>This vignette is not needed for <em>using</em> the async package. It
may be useful for developers of async methods, and certainly for people
working on the async package itself. Make sure you read the README and
also the manual page of <code><a href="../reference/deferred.html">?deferred</a></code> before reading this
vignette.</p>
<p>If you think that this document conflicts the source code, please
report an issue in the async issue tracker.</p>
</div>
<div class="section level2">
<h2 id="the-event-loop">The event loop<a class="anchor" aria-label="anchor" href="#the-event-loop"></a>
</h2>
<p>The async event loop is modeled after the libuv event loop. It is
possible that we’ll switch to the libuv event loop later.</p>
<div class="section level3">
<h3 id="polling">Polling<a class="anchor" aria-label="anchor" href="#polling"></a>
</h3>
<p>The essential feature of the event loop is that it is
<em>polling</em> for all I/O, in a single <code><a href="http://processx.r-lib.org/reference/poll.html" class="external-link">processx::poll()</a></code>
call. This allows the quickest possible processing of I/O, as
<code>poll()</code> returns as soon as an event is available for
processing.</p>
<p>Ideally, a single <code>poll()</code> call should return <em>all</em>
available events, and this is indeed the case for Unix, but currently
<em>not</em> for Windows. To improve this on Windows, we would need to
use <code>GetQueuedCompletionStatusEx()</code> in processx, which can
remove multiple packets from the IOCP. HTTP is already handled properly
on Windows as well, because we use <code>select()</code>, which returns
all events.</p>
</div>
<div class="section level3">
<h3 id="pollables">Pollables<a class="anchor" aria-label="anchor" href="#pollables"></a>
</h3>
<p><code><a href="http://processx.r-lib.org/reference/poll.html" class="external-link">processx::poll()</a></code> is able to poll for various types of
I/O: * processx processes (not used in async currently), * processx
connections, this is used in async to poll for all processes,
i.e. <code><a href="../reference/run_process.html">run_process()</a></code>, <code><a href="../reference/run_r_process.html">run_r_process()</a></code> and
<code><a href="../reference/call_function.html">call_function()</a></code>. * curl file descriptors, this is used in
async to poll for HTTP.</p>
</div>
<div class="section level3">
<h3 id="interrupts">Interrupts<a class="anchor" aria-label="anchor" href="#interrupts"></a>
</h3>
<p><code><a href="http://processx.r-lib.org/reference/poll.html" class="external-link">processx::poll()</a></code> is interruptible on all platforms. THis
is implemented by polling in a loop, for a short amount of time only
(~200ms) and then checking for interrupts.</p>
<div class="section level4">
<h4 id="processes">Processes<a class="anchor" aria-label="anchor" href="#processes"></a>
</h4>
<p>Processes are polled using their “poll connections”. This is an extra
connection in addition to standard output and error, and for
<code><a href="../reference/run_process.html">run_process()</a></code> and <code><a href="../reference/run_r_process.html">run_r_process()</a></code> it is used
to poll for the termination of the process. For the worker pool,
i.e. <code><a href="../reference/call_function.html">call_function()</a></code>, it is used to communicate back to the
main process, so it can be used to poll for the completion of the remote
function call.</p>
<p>On Unix, polling processx connections simply uses file descriptor and
the <code>poll(2)</code> system call.</p>
<p>On Windows, polling processx connections uses overlapped I/O and
IOCPs. Since on Windows you cannot poll without reading, all connections
are also buffered.</p>
</div>
<div class="section level4">
<h4 id="http">HTTP<a class="anchor" aria-label="anchor" href="#http"></a>
</h4>
<p>Implementing HTTP polling is significantly more difficult than only
polling processx connections. We list the most significant issues and
their workarounds here.</p>
<div class="section level5">
<h5 id="the-curl-package">The curl package<a class="anchor" aria-label="anchor" href="#the-curl-package"></a>
</h5>
<p>The curl package implements a HTTP client, it uses libcurl
internally. In async, we do not intend to re-implement a HTTP client,
but we just want to use curl. We added the
<code><a href="https://rdrr.io/pkg/curl/man/multi.html" class="external-link">curl::multi_fdset()</a></code> function to curl, this returns the
socket file descriptiors to poll for curl’s HTTP connections and also
the timeout value that curl prefers. We poll these file descriptors with
<code><a href="http://processx.r-lib.org/reference/poll.html" class="external-link">processx::poll()</a></code> and if any of them have data, we call
<code><a href="https://rdrr.io/pkg/curl/man/multi.html" class="external-link">curl::multi_run()</a></code>. We also use the returned timeout value
as a maximum limit for the poll, unless we also have lower limits for
other I/O or timers.</p>
</div>
<div class="section level5">
<h5 id="the-dns-resolver">The DNS resolver<a class="anchor" aria-label="anchor" href="#the-dns-resolver"></a>
</h5>
<p>HTTP queries usually involve DNS resolution. This is done
automatically by libcurl, but we need to handle it somewhat specially,
because libcurl does not report a file descriptor for it. E.g. if a curl
multi handle has a single pending HTTP query which is in the DNS
resolution phase, then <code><a href="https://rdrr.io/pkg/curl/man/multi.html" class="external-link">curl::multi_fdset()</a></code> returns zero
file descriptors. But we still need to call
<code><a href="https://rdrr.io/pkg/curl/man/multi.html" class="external-link">curl::multi_run()</a></code> to allow the DNS resolution to complete,
and the actually HTTP to start. To work around this, we always call
<code><a href="https://rdrr.io/pkg/curl/man/multi.html" class="external-link">curl::multi_run()</a></code> if some curl handles are in the DNS
resolution phase and we used curl’s returned timeout value for the
poll.</p>
</div>
<div class="section level5">
<h5 id="http-timeouts">HTTP timeouts<a class="anchor" aria-label="anchor" href="#http-timeouts"></a>
</h5>
<p>HTTP timeouts also have to be handled specially, because we need to
call <code><a href="https://rdrr.io/pkg/curl/man/multi.html" class="external-link">curl::multi_run()</a></code> even if there is no data on the curl
sockets. Similarly to the DNS resolution workaround, we always call
<code><a href="https://rdrr.io/pkg/curl/man/multi.html" class="external-link">curl::multi_run()</a></code> if we used curl’s timeout for the poll.
This makes sure that it is called no later than requrested by curl
itself, and curl can take care of the HTTP timeouts.</p>
</div>
<div class="section level5">
<h5 id="polling-on-windows">Polling on Windows<a class="anchor" aria-label="anchor" href="#polling-on-windows"></a>
</h5>
<p>Polling a mix of processx connections (IOCP) and curl sockets is not
trivial on Windows. We cannot add the sockets to processx’s IOCP,
because that would cause complications if libcurl also started to use
IOCP for them, and also with the buffering. The right approach is to use
<code>select()</code> for these sockets, in parallel with the IOCP poll.
So we do these in two threads.</p>
<p>The main thread runs <code>select()</code> and the background thread
polls the IOCP. If there is data on either threads, they must wake up
the other thread. For this we add an extra socket on localhost to the FD
set of curl sockets. This is the “notification socket”, and the IOCP
polling thread writes data to this socket as soon as its poll has
finished. Similarly, the main thread puts a special event into the IOCP,
as soon as the <code>select()</code> has finished.</p>
<p>To avoid race conditions, neither thread can assume that it woke up
the other, even if it has sent a wake up event. We need to keep this in
mind when writing the Windows poll code in processx. In particular * the
<code>select()</code> thread may or may not return “real” results,
independently of whether the notification socket is set. * the IOCP
thread may or may not return a real result. A “non-real” result can be
recognized from the special key, and a zero <code>OVERLAPPED</code>
pointer.</p>
<div class="section level6">
<h6 id="fd_set-on-windows">FD_SET on Windows<a class="anchor" aria-label="anchor" href="#fd_set-on-windows"></a>
</h6>
<p><code>FD_SETSIZE</code> is 64 by default on Windows, which is much
less than what we need, so we set it to 32767. I wonder if libcurl does
anything about this.</p>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="nested-event-loops">Nested event loops<a class="anchor" aria-label="anchor" href="#nested-event-loops"></a>
</h3>
<p>Nested event loops are in general fine, and they “just work”, because
we are polling the I/O of the active event loop only.</p>
<p>There are some complications with the worker pool, however. In
particular, worker pool tasks might terminate when their event loop is
inactive. See the section about the worker pool for more about this.</p>
<p>Another potential issue with nested event loops is that HTTP requests
might time out and HTTP connections might disconnect while their event
loops are inactive. There is not much we can do about this, without
running the HTTP on a background thread for example, but that is
difficult as well as we cannot call R functions from the background
thread, so we would need to use (lib)curl’s C multi handles directly,
which is less than ideal.</p>
</div>
</div>
<div class="section level2">
<h2 id="the-worker-pool">The worker pool<a class="anchor" aria-label="anchor" href="#the-worker-pool"></a>
</h2>
<p>The worker pool is a set of background processes, controlled via
<code><a href="https://callr.r-lib.org/reference/r_session.html" class="external-link">callr::r_session</a></code> objects. <code><a href="../reference/call_function.html">call_function()</a></code>
queues a function call to run on the worker pool, and the async event
loop schedules the tasks to the queue. The workers can be polled via
their poll connections.</p>
<p>There is a single worker pool for an R process. If multiple event
loops are active, then they share the worker pool. The reason for this
is that it would be too costly to start a worker pool when creating an
event loop (i.e. for a <code><a href="../reference/synchronise.html">synchronise()</a></code> call). In general it
seems that the life time of the worker pool is typically longer than the
life time of an event loop.</p>
<p>Sharing the worker pool causes some complications, which we need to
handle in the event loop. In partucular, a worker pool task might finish
while its event loop is not active. In this case, we free the worker,
and do not remove the task’s results from the worker pool. When its
event loop will be active again, it will check for any tasks that have
been completed while the event loop was inactive.</p>
<p>Moreover, when choosing a new task to run on the worker pool, we may
choose a task that does not belong to the active event loop. This is
fine, our only restriction is that the task must be <em>removed</em>
from the worker pool when its event loop is active.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by <a href="https://github.com/gaborcsardi" class="external-link">Gábor Csárdi</a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
